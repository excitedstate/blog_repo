---
title: 分布式系统复习
date: 2024-06-29 20:12:59
tags: 分布式系统
categories: 
- 分布式系统
---
# 分布式系统复习

> 参考资料:
>
> - [极客时间-分布式协议和算法](https://time.geekbang.org/column/intro/100046101?code=VYYN3ZrEYyTDBoS8WGbkNcoJfZFLHbUb%2FVSgynFt-9c%3D)
> - [DDIA](http://ddia.vonng.com/#/)
>
> 部分语段使用[kimi.ai](https://kimi.moonshot.cn/)等人工智能产品生成
>
> 本文仅为作者复习分布式系统常用协议和算法而写，一家之言。文中任何观点都有可能存在事实错误，请批判性地阅读。
>
> 作者无法监督您如何使用本文中的语料，不建议将本文用于任何培训或机器学习训练场景，谢谢合作。

## 为什么要学习分布式算法

分布式是互联网络发展的大趋势。当单机算力达到理论极限时，将多台物理上独立的计算机通过“总线"连接到一起工作是一种很自然的想法。这些组织到一起的计算机将合作完成一些工作，其关键就是分布式协议和算法。优秀的协议和算法能够这些计算机协作时更专注于任务本身，提升任务效率和完成质量。由此可见，分布式算法是分布式技术的核心；或者说，分布式系统中最重要的事情，就是选择或设计合适的算法，解决分布式场景中遇到的各种问题，其中最典型的就是可用性和一致性的权衡。

## 拜占庭问题之解

### 口令消息型拜占庭问题之解

> 如果叛将人数为 m,将军人数不能少于 3m + 1 ,那么拜占庭将军问题就能解决了
>
> 换言之，n 位将军,最多能容忍 (n - 1) / 3 位叛将。
>
> 满足条件时，无论叛将如何扰乱通信过程，剩下的将军们总能达成一致的决定，或一同进攻，或一同撤退。

### 签名消息型拜占庭问题之解

> 对消息附加不可伪造且任何人都可验证的数字签名。数字签名可追踪溯源。这是一种对通信过程加以保护的技术，在这种情形下，叛将会被其他将军发现。

### BFT和CFT

BFT是拜占庭容错算法。在存在恶意节点行为的场景中(比如在数字货币的区块链技术中),必须使用拜占庭容错算法；

CFT是故障容错算法（非拜占庭容错算法）。CFT 解决的是分布式的系统中存在故障,但不存在恶意节点的场景下的共识问题。

## CAP理论

CAP理论在分布式算法中具有重要地位。它是一个非常重要的思考框架，能指导我们根据现实需求设计分布式系统。CAP理论用于描述分布式系统中一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）之间的关系，这里提到的三个单词是分布式系统的三个基本需求，有些文章也将他们成为分布式系统三要素或CAP三要素。

### 基本概念(kimi.ai辅助创作)

- **一致性**：在分布式系统中，当一个数据项被更新后，所有节点应保证对该数据项的读取都是最新的值。换言之，对于任意数据项的读取，从任意节点进行得到的结果都是一致的。
- **可用性**：分布式系统应保证客户端的每个请求都能接收到响应，无论是读请求还是写请求，系统都应该在有限的时间内返回**可解释的**结果。
- **分区容忍性** ：分布式系统应能够继续运行，即使**网络分区**发生，即系统的一部分与其余部分断开连接。

> CAP中的C和ACID中C都被译为一致性，但我觉得两者对用户做出的承诺还是有区别的。以下是作者的一些理解。
>
> - CAP理论中的C强调的是分布式节点上的数据一致或状态一致，这使得客户端如何从哪个节点上获取数据，都能得到同一版本的数据，这里的C和业务系统没有关系，描述的是分布式系统的状态。
> - ACID中的C指的是数据库版本的一致，强调在某一事务执行前后数据库都符合所有预定义的规则和约束。对于RDBMS而言，这些规则和约束往往是业务系统定义且从DBMS实现的，大体上可分为三类：
>   - 第一类是实体完整性、参照完整性和用户自定义完整性，这些会体现在表的元数据上（DDL）
>   - 第二类是触发器，其实是一种一些可被SQL描述的额外逻辑过程，发生在特定事件触发时
>   - 第三类是由事务操作流程保证的，需要事务原子性保证，最典型的例子是银行转账；如果没有原子性保证，第一类和第二类约束可能还是能正确完成，但是整个系统已经处在一个不一致的状态了。
> - 无论是哪一类，ACID中的C需要业务系统自己来定义，DBMS提供的是一套框架和流程，它无法确切的知道业务想要的C是什么。只要业务系统自己定义的足够清晰，保证一致性就是DBMS的工作而不是业务系统的工作

### CAP理论的表述方法

在任何分布式系统中，无法同时满足一致性、可用性和分区容错性这三个要求。在网络分区发生的情况下，系统只能选择满足其中的两个。以下是三种可能的权衡：

* **CA（Consistency + Availability）** ：系统牺牲分区容忍性，保证一致性和可用性。在这种情况下，如果发生网络分区，系统可能会拒绝服务，直到网络恢复正常。
* **CP（Consistency + Partition Tolerance）** ：系统牺牲可用性，保证一致性和分区容忍性。在网络分区的情况下，系统仍然保证数据的一致性，但可能会拒绝一些请求。
* **AP（Availability + Partition Tolerance）** ：系统牺牲一致性，保证可用性和分区容忍性。在网络分区的情况下，系统继续接受请求并尽可能地提供服务，但可能返回的是旧的数据。

> 作者认为，CAP理论还可以描述成以下形式：
>
> - 在网络分区尚未发生的情况下，系统应当尽可能保证一致性和可用性，因为此时分区容错性无需考虑
> - 一旦网络分区发生，系统就应该在一致性和可用性间做出选择。如果选择保证一致性，则系统可能拒绝一些请求；如果选择保证可用性，系统将继续提供服务，但可能返回的是旧的数据，或两次返回的结果不一致。

### 典型案例

| 模型    | 特点                                                                                                                                            | 案例                     |
| ------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ |
| CA 模型 | 在分布式系统中不存在。因为舍弃 P,意味着舍弃分布式系统                                                                                           | 单机版关系型数据库 MySQL |
| CP 模型 | 采用 CP 模型的分布式系统,一旦因为消息丢失、延迟过高发生了网络分区, 就影响用户的体验和业务的可用性 因为为了防止数据不一致,集群将拒绝新数据的写入 | ZooKeeper,Etcd 和 HBase  |
| AP 模型 | 实现了服务的高可用。用户访问系统的时候,都能得到响应数据,不会出现响应错误.但当出现分区故障时,相同的读操作,访问不同的节点,得到响应数据可能不一样  | Cassandra 和 DynamoDB    |

## 设计一致性优先的分布式系统

### 分布式事务

在分布式系统的中，多个服务或组件之间需要协调。**分布式事务**是一种机制，确保一系列操作要么全部成功完成，要么全部失败回滚。

> 分布式事务描述的似乎是原子性。但事实上分布式事务设计的目的是保证数据的一致性和完整性。
>
> 作者认为，原子性和一致性是数据系统的两个承诺，但都服务于正确性目标。

实现分布式事务的算法有很多，比较著名的是2PC

### 两阶段提交协议（2PC，two-phase commit）

假设集群中有ABC三台服务器，用户向A发起一个请求，这个请求可能是写入一个键值，或者通告一个状态变更。但要求ABC上都要做一次这个操作，即保持这个操作的一致性。

A作为事务协调者，使用2PC实现分布式事务的流程如下：

第一阶段（提交请求阶段，投票阶段）：A分别向B和C发送报文，同步要执行的操作的相关信息；当B和C收到消息后，会评估条件是否符合；

- 若条件符合，则预留资源，返回同意；
- 若条件不符合，则返回拒绝

第二阶段（提交执行阶段，完成阶段）：A根据投票阶段，如果B和C都返回同意，则A向B和C发送COMMIT指令，要求完成操作；若存在拒绝，则A向B和C发送ABORT指令，撤销事务操作并释放预留资源。

> 优点：
>
> - 实现了分布式事务的要求：要么全部提交，要么全部回滚
>
> 缺点：
>
> - 资源占用：一旦进入准备阶段，部分资源就会被预留以确保完成阶段能够成功；这可能导致长时间的资源占用
> - 单点故障：如果协调者在提交阶段失败，而没有发送提交或者回滚命令，参与者将处于不确定状态，无法继续处理其他事务
>
> 不能只通过引入超时解决2PC的问题，可能会引起不一致问题

### Try-Confirm-Cancel（TCC）

> 本质上还是两阶段：Confirm和Cancel二选一，比2PC多一个撤销，允许撤销事务，然后幂等。
>
> TCC可以看作是一种对2PC的补充和扩展，特别是在需要处理复杂业务逻辑和长事务的场景中。TCC通过引入补偿机制，提供了一种更灵活和容错性更强的分布式事务处理方案。然而，TCC也带来了更高的业务侵入性和事务管理复杂性，因此在选择使用TCC之前需要仔细评估业务需求和系统特点。

TCC（Try-Confirm-Cancel）是一种分布式事务处理模式，它通过将一个分布式事务拆分成三个阶段来实现事务的最终一致性。TCC是一种补偿事务机制，其核心思想是将事务的提交过程分为两个阶段：尝试阶段（Try）和确认阶段（Confirm），并在失败时执行取消阶段（Cancel）来保证数据的一致性。

**Try阶段** ：

* 在这个阶段，服务会尝试执行业务操作，并记录必要的执行状态和数据，以便在后续的阶段中进行确认或取消。
* 这个阶段需要保证操作的幂等性，即多次执行Try操作的结果与执行一次相同。

**Confirm阶段** ：

* 如果Try阶段成功，服务将进入Confirm阶段，这个阶段会正式提交业务操作，完成事务。
* Confirm操作应该是幂等的，以确保即使多次调用也不会影响最终结果。

**Cancel阶段** ：

* 如果Try阶段失败，服务将进入Cancel阶段，这个阶段会撤销Try阶段所做的操作，以保证数据的一致性。
* 与Confirm阶段类似，Cancel操作也应该是幂等的。

#### TCC的特点

* **幂等性** ：TCC要求Try、Confirm和Cancel操作都是幂等的，以确保在分布式系统中即使出现重复调用也不会影响最终结果。
* **业务侵入性** ：TCC通常需要业务逻辑的配合，因为需要在业务层面实现Try、Confirm和Cancel三个操作。
* **最终一致性** ：TCC不保证**事务的即时一致性**，而是通过**补偿机制**保证最终一致性。
* **灵活性** ：TCC允许在分布式系统中灵活地处理事务，特别是在业务逻辑复杂或需要高度定制化的场景中。

#### TCC的适用场景

* 当业务操作可以明确地分为准备阶段和提交阶段时。
* 当需要高度定制化的事务处理逻辑时。
* 当系统需要处理长事务或需要跨服务协调时。

#### TCC的局限性

* **业务侵入性** ：需要业务逻辑的深度参与，增加了业务开发的复杂性。
* **事务管理复杂性** ：需要额外的逻辑来管理事务的各个阶段，增加了系统的复杂性。
* **失败恢复** ：在网络分区或服务故障的情况下，可能需要额外的机制来处理事务的失败恢复。

## BASE理论

BASE理论是CAP理论中AP的延，是对互联网大规模分布式系统的总结，强调可用性。BASE理论的核心是基本可用(Basic Availability)、软状态(Soft State)和最终一致性(Eventual Consistency)。
其中，软状态描述的是实现服务可用性的时候系统可以处于一种过渡状态，允许短暂的不一致，最终是要达到一致性的。

### 实现基本可用的方案

- 流量削峰: 把不同的访问请求错开, 削弱请求峰值;
- 延迟响应: 请求不会立即响应, 而是先在队列中排队. 当系统有空闲资源时再安排响应
- 体验降级: 降低服务质量, 提升服务速度. 比如在高峰期提供低质量图像
- 过载保护: 现有请求已经达到服务峰值, 服务器直接请求队列中的请求, 并返回Timeout. 用户可继续提交请求，等待服务可用

> 过载保护也算是**可用**吗? 感觉服务已经暂时不可用了! 至少对于其中的一些用户而言。但过载保护的意义在于保证系统不崩溃。只要系统不崩溃, 总能在高峰期过后恢复到正常服务水平。从长远看是有意义的。

### 最终一致性

允许分布式系统中的各个节点间存在短暂的不一致.

#### 实现最终一致性, 以哪个版本为准

- 以最新写入的数据为准
- 以第一次写入的数据为准

#### 具体方式是什么?

| 方式     | 说明                                                                                                   | 典型例子                      |
| -------- | ------------------------------------------------------------------------------------------------------ | ----------------------------- |
| 读时修复 | 在读取数据时，检测数据的不一致，进行修复。这可能要求分布式系统同时得到两个节点上的数据                 | Cassandra的Read Repair实现；  |
| 写时修复 | 在写入数据时，检测数据的不一致，进行修复。出现写失败时把数据缓存下来，然后定时重传，修复数据的不一致性 | Cassandra的Hinted Handoff实现 |
| 异步修复 | 通过定时对账检测部分数据的一致性，并修复                                                               | Dynamo Gossip                 |
